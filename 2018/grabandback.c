#pragma config(Sensor, in1,    armpos,         sensorPotentiometer)
#pragma config(Sensor, dgtl1,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  renc,           sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rLED,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl6,  gLED,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, lenc,           sensorQuadEncoder)
#pragma config(Motor,  port1,           rm,            tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port8,           Arm,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           Claw,          tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port10,          lm,            tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* This demo program is to let robot move forward to
 * grab a cardboard brick and bring it back.
 * Press Btn5U to start robot action
 * Press Btn6U to let robot make a back turn and get back original place
 * Press Btn8R to enter remote control mode
 * Press both Btn5D and Btn6D to enter calibration mode
 * In calibration mode
 *  1. Press Btn7U or Btn7D to increase or decrease back turn value.
 *  1. Press Btn8U or Btn8D to increase or decrease right wheel speed adjustment (rsa) value
 * the right wheel speed = left wheel speed + rsa
 */

/* LED information decoding
* Green LED on only: ready to receive command
* red LED on only: calibration mode
* both LEDs on: remote control mode
* Red LED blink to indicate a value is increased or decreased by one step
*/

/* remote control instruction
 * use the two joy sticks to control robot move forward and backward
 * Use Btn5U and Btn5D to control claw close and open
 * Use Btn6U and Btn6D to control arm up and down
 *
 */

// define the potentialmeter reading for arm upper and lower
// limits position. These values needed to measurement for
// each robot individually.
//

// These values are for Robot Sea Horse
#define up 100
#define lp 1000


/* this function moves arm to a given postion, which is definied
* by its corresponding potentialmeter reading
* The function implementation assume:
* up<lp,
* positive motor speed moves arm up.
* Modification is needed for different setup
*/

int btv = 180;        // back turn value
int rsa = 0;          // right wheel speed adjustment
bool btnrel = true;
bool b8rrel = true;

void moveArm(int position, int agf) {
	if (position<up)        // check position limits.
  else if (position>lp)
  	position =lp;

	int pos;
	bool cont=true;
	bool brake = false;

	while(cont) {
		pos=position-SensorValue(armpos);
		if(pos>20) {  // the arm is higher than the desirable position
		  motor[Arm]=-15;      // lower arm
		  brake = true;
		}
		else {
			if (pos<-20) {  // the arm is lower than the desirable position
				motor[Arm]=40;   // raise arm
				brake = false;
				}
	    else {            // arm at the desirable position
	    	cont=false;
	    	if (brake) {      // need to apply brake to counter inertia
	    		motor[Arm]=20;
	    		wait1Msec(50);
	    	 }
	    	   motor[Arm]=agf;   // this is to counter gravity and hold motor at that position
	    	   //wait1Msec(100);
	    	   //motor[Arm]=0;

	    }   // end if (pos<-20)... else...
	  }   // end if (pos>20)... else...
  }  	  // end while
}       // end sub routine


// open the claw
void openClaw() {
	motor[Claw]=30;
	wait1Msec(1500);
	motor[Claw]=0;
}

// close the claw and have it to maintain certain pressure
void closeClaw(int pressure) {
	motor[Claw]=-30;
	wait1Msec(1000);
	motor[Claw]=pressure;
}

// release the clas pressure
void relaxClaw() {
	motor[Claw]=0;
}

// let robot make turn of a given degree
// degree number can be positive or negative
//
void turn (int degree) {
	int target;
	int speedR, speedL;

	target=abs(3*degree);

	if (degree>0) {
		speedR=90+rsa;
		speedL=-90;
	}
	else {
		speedR=-90-rsa;
		speedL=90;
	}

	SensorValue[renc]=0;                  // reset the encoder counters beforing using them
	SensorValue[lenc]=0;                  // reset the encoder counters beforing using them

	while (abs(SensorValue[renc])<target | abs(SensorValue[lenc])<target) {
		motor[rm]=speedR;
		motor[lm]=speedL;
		wait1Msec(10);
	}

	// apply brake
	if (speedR>0){
		speedR=-20;
		speedL=20;
	}
	else {
		speedR=20;
		speedL=-20;
	}

	motor[rm]=speedR;
	motor[lm]=speedL;
	wait1Msec(30);
	motor[rm]=0;
	motor[lm]=0;
}

// let the robot march dist distance in inches
// wheel diameter is 4 inches
// encoder value increase by 360 if wheel rotates 360 degree
// encoder target value = 360*dist/(pi*4)=dist*28.64789
// dist can be either positive (move forward) or negative (backing up)
//
void march(float dist){
	int target;
	int speedR, speedL;
	target=(int) abs(dist*28.64789);

	if (dist>0){
		speedR=90;
		speedL=90;
		}
	else {
		speedR=-90;
		speedL=-90;
	}

	SensorValue[renc]=0;                  // reset the encoder counters beforing using them
	SensorValue[lenc]=0;                  // reset the encoder counters beforing using them

	while (abs(SensorValue[renc])<target | abs(SensorValue[lenc])<target) {
		motor[rm]=speedR;
		motor[lm]=speedL;
		wait1Msec(10);
	}

	// apply brake
	if (speedR>0){
		speedR=-20;
		speedL=20;
	}
	else {
		speedR=20;
		speedL=-20;
	}

	motor[rm]=speedR;
	motor[lm]=speedL;
	wait1Msec(30);
	motor[rm]=0;
	motor[lm]=0;
}

// function for moving forward, picking up the box and coming back
void pickup( ) {
	moveArm(900, 5);
	openClaw();
	march(36);
	closeClaw(10);
	moveArm(200, 10);
	turn(btv);
	march(36);
	moveArm(900, 5);
	openClaw();
}

// function for moving back to the original position
void back2post() {
	turn(btv);
	// add other instructions for fine adjustment
}

// calibration fucntion
void calibrate() {
  bool calcont = true;

  bool b7up = false;
  bool b7dp = false;

  bool b8up = false;
  bool b8dp = false;

  turnLEDOn(rLED);

  while(calcont) {

   // check if receive command to exit calibration
   if ((!vexRT(Btn5D)) & (!vexRT(Btn6D))) {      // both buttons are released
     btnrel=true;
     turnLEDOff(gLED);
   }
   if (btnrel & vexRT(Btn5D) & vexRT(Btn6D)) {  // exit calibration mode
     calcont = false;
     turnLEDOff(rLED);
     btnrel = false;
   }

   // check if to increase back turn value btv
   if (vexRT(Btn7U))
     b7up = true;

   if (b7up & (!vexRT(Btn7U))) {
     b7up = false;
     btv = btv + 1;
     turnLEDOff(rLED);
     wait1Msec(100);
     turnLEDOn(rLED);
   }

   // check if to decrease back turn value btv
   if (vexRT(Btn7D))
     b7dp = true;

   if (b7dp & (!vexRT(Btn7D))) {
     b7dp = false;
     btv = btv - 1;
     turnLEDOff(rLED);
     wait1Msec(100);
     turnLEDOn(rLED);
   }

   // check if to increase right wheel speed adjustment rsa
   if (vexRT(Btn8U))
     b8up = true;

   if (b8up & (!vexRT(Btn8U))) {
     b8up = false;
     rsa = rsa + 1;
     turnLEDOff(rLED);
     wait1Msec(100);
     turnLEDOn(rLED);
   }

   // check if to decrease right wheel speed adjustment rsa
   if (vexRT(Btn8D))
     b8dp = true;

   if (b8dp & (!vexRT(Btn8D))) {
     b8dp = false;
     rsa = rsa - 1;
     turnLEDOff(rLED);
     wait1Msec(100);
     turnLEDOn(rLED);
   }
 }
	turnLEDOff(rLED);
	turnLEDOn(gLED);
}

void remoteControl() {

   // light red LED
   turnLEDOn(rLED);

   bool cont = true;

  while (cont) {
   // check if receive command to exit remote control mode
   if (!vexRT(Btn8R))       // Btn8R is released
      b8rrel= true;

   if (b8rrel & vexRT(Btn8R) ) {  // Btn8R is pressed again to exit remote control mode
     cont = false;
     b8rrel = false;
   }

   // start remote control function
   // claw control
   while(vexRT[Btn5D]){
		motor[Claw]=30;}

	 while(vexRT[Btn5U]){
		motor[Claw]=-30;}

   motor[Claw]=0;

   // motor control
	int lvalue;
	int rvalue;

	lvalue=vexRT[Ch3];
	if(lvalue<10&&lvalue>-10)
		lvalue=0;

	rvalue=vexRT[Ch2];
	if(rvalue<10&&rvalue>-10)
		rvalue=0;

  int dist = SensorValue(sonar);

  if (dist<50 & dist!=-1) {
  	if (lvalue>0)
          lvalue=0;

    if (rvalue>0)
         rvalue=0;
	 }

	 motor[lm]=lvalue;
	 motor[rm]=rvalue;

	// arm control
	while(vexRT[Btn6U] & SensorValue(armpos)>up){
		motor[Arm]=30;}

	while(vexRT[Btn6D] & SensorValue(armpos)<lp){
		motor[Arm]=-30;}

	motor[Arm]=0;

 }

 // turn of red LED
 turnLEDOff(rLED);
}

// Main funciton
task main() {

 turnLEDOn(gLED);     // notify user that the robot is ready

 while(true) {

    // check if any button is pressed
    if (vexRT[Btn5U])
    	 pickup();

    if (vexRT[Btn6U])
    	 back2post();

    // Btn8R is pressed to enter remote control mode
    if (b8rrel & vexRT[Btn8R]) {
    	b8rrel = false;
    	remoteControl();
      }

    if (!vexRT(Btn8R))
    	b8rrel = true;


    if (btnrel & vexRT(Btn5D) & vexRT(Btn6D)) {
    	btnrel = false;
    	calibrate();
     }

    if ((!vexRT(Btn5D)) & (!vexRT(Btn6D)))      // both buttons are released
       btnrel=true;
  }
}
