#pragma config(Sensor, in1,    armpos,         sensorPotentiometer)
#pragma config(Sensor, dgtl1,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  renc,           sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rLED,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl6,  gLED,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl7,  yLED,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, lenc,           sensorQuadEncoder)
#pragma config(Motor,  port1,           rm,            tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port8,           Arm,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           Claw,          tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port10,          lm,            tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* This program is to demonstrate different robot moving patterns
 *  1. Following mode: Press Btn5U to enter this mode, Press Btn5U to exit
 *  2. Runing on a cycle: Press Btn6U to enter this mode, Press Btn6U to exit
 *  3. Run a square: Press Btn8R to enter this mode, Press Btn8R to exit
 *  4  Remote control: Press Btn8L to enter this mode, Press Btn8L to exit
 *  5. Calibarion mode: Press both Btn5D and Btn6D, both Green and Red LED on
 *
 * In calibration mode
 *  1. Press Btn7U or Btn7D to increase or decrease right anlge turn value, rav
 *  2. Press Btn8U or Btn8D to increase or decrease right wheel speed adjustment (rsa) value
 *     the right wheel speed = left wheel speed + rsa when running straight line
 *  3. Press Btn7L or Btn7R to increase or decrease right wheel speed differential value rsd
 *     the right wheel speed = left wheel speed - rsd when running cycles
 */

 /* LED information decoding
  * Green LED on only: the robot is ready for receiving command
  * Green and Yellow LED on: following mode
  * Yellow LED only: running a circle
  * Green and Red LED on: running a square
  * All LEDs on: remote control
  * Red LED on only: calibartion mode
  */

// define the potentialmeter reading for arm upper and lower
// limits position. These values needed to measurement for
// each robot individually.
//
// These values are for robot Geico
#define up 3200
#define lp 1380

// define how many sonar sensor samples are collected in each obstacle detection
#define num 9

// declare and initialize flags for button press operation
bool btnrel = true;
bool b5urel = true;
bool b8lrel = true;

// declare and initialize global variables
int rtv = 90;        // right turn value
int rsa = 0;          // right wheel speed adjustment for running straight line
int lwt = 4000;
float rsd = 0.3;     // right wheel speed differential for running on cycles


/* Majority voting function
 * It find the average of the majority group of the sonar reading
 */
int majvote(int *dist, int len)
{
	int total=0;
  int k;
	for (k=0; k<len; k++)
		total=total+dist[k];

	int avg=total/len;

	int asum=0;
	int bsum=0;
	int anum=0;
	int bnum=0;

	for (k=0; k<len; k++)
		if (dist[k]>avg){
			asum=asum+dist[k];
			anum=anum+1;
		}
		else {
			bsum=bsum+dist[k];
			bnum=bnum+1;
		}

	int vote;
	if (anum>bnum)
		vote=asum/anum;
	else
		vote=bsum/bnum;

	return vote;
}


/* this function moves arm to a given postion, which is definied
* by its corresponding potentialmeter reading
* The function implementation assume:
* up<lp,
* positive motor speed moves arm up.
* Modification is needed for different setup
*/

void moveArm(int position, int agf) {
	if (position>up)        // check position limits.
  else if (position<lp)
  	position =lp;

	int pos;
	bool cont=true;
	bool brake = false;

	while(cont) {
		pos=position-SensorValue(armpos);
		if(pos>20) {  // the arm is lower than the desirable position
		  motor[Arm]=40;      // raise arm
		  brake = false;
		}
		else {
			if (pos<-20) {  // the arm is higher than the desirable position
				motor[Arm]=-15;   // raise arm
				brake = true;
				}
	    else {            // arm at the desirable position
	    	cont=false;
	    	if (brake) {      // need to apply brake to counter inertia
	    		motor[Arm]=20;
	    		wait1Msec(50);
	    	 }
	    	   motor[Arm]=agf;   // this is to counter gravity and hold motor at that position
	    	   //wait1Msec(100);
	    	   //motor[Arm]=0;

	    }   // end if (pos<-20)... else...
	  }   // end if (pos>20)... else...
  }  	  // end while
}       // end sub routine


// open the claw
void openClaw() {
	motor[Claw]=30;
	wait1Msec(1500);
	motor[Claw]=0;
}

// close the claw and have it to maintain certain pressure
void closeClaw(int pressure) {
	motor[Claw]=-30;
	wait1Msec(1000);
	motor[Claw]=pressure;
}

// release the clas pressure
void relaxClaw() {
	motor[Claw]=0;
}

// let robot make turn of a given degree
// degree number can be positive or negative
//
void turn (int degree) {
	int target;
	int speedR, speedL;

	target=abs(3*degree);

	if (degree>0) {
		speedR=90+rsa;
		speedL=-90;
	}
	else {
		speedR=-90-rsa;
		speedL=90;
	}

	SensorValue[renc]=0;                  // reset the encoder counters beforing using them
	SensorValue[lenc]=0;                  // reset the encoder counters beforing using them

	while (abs(SensorValue[renc])<target | abs(SensorValue[lenc])<target) {
		motor[rm]=speedR;
		motor[lm]=speedL;
		wait1Msec(10);
	}

	// apply brake
	if (speedR>0){
		speedR=-20;
		speedL=20;
	}
	else {
		speedR=20;
		speedL=-20;
	}

	motor[rm]=speedR;
	motor[lm]=speedL;
	wait1Msec(30);
	motor[rm]=0;
	motor[lm]=0;
}

// let the robot march dist distance in inches
// wheel diameter is 4 inches
// encoder value increase by 360 if wheel rotates 360 degree
// encoder target value = 360*dist/(pi*4)=dist*28.64789
// dist can be either positive (move forward) or negative (backing up)
//
void march(float dist){
	int target;
	int speedR, speedL;
	target=(int) abs(dist*28.64789);

	if (dist>0){
		speedR=90;
		speedL=90;
		}
	else {
		speedR=-90;
		speedL=-90;
	}

	SensorValue[renc]=0;                  // reset the encoder counters beforing using them
	SensorValue[lenc]=0;                  // reset the encoder counters beforing using them

	while (abs(SensorValue[renc])<target | abs(SensorValue[lenc])<target) {
		motor[rm]=speedR;
		motor[lm]=speedL;
		wait1Msec(10);
	}

	// apply brake
	if (speedR>0){
		speedR=-20;
		speedL=20;
	}
	else {
		speedR=20;
		speedL=-20;
	}

	motor[rm]=speedR;
	motor[lm]=speedL;
	wait1Msec(30);
	motor[rm]=0;
	motor[lm]=0;
}

// function for moving forward, picking up the box and coming back
void pickup( ) {
	moveArm(900, 5);
	openClaw();
	march(36);
	closeClaw(10);
	moveArm(200, 10);
	turn(rtv);           // can be 180, or 90 depending on applications
	march(36);
	moveArm(900, 5);
	openClaw();
}

// function for moving back to the original position
void back2post() {
	turn(rtv);			// can be 180, or 90 depending on applications
	// add other instructions for fine adjustment
}

/* follow function
 * It measures the distance between robot and its guider
 * and follow its guider.
 */
void follow() {

  turnLEDOn(yLED);        // turn on yellow LED

  int dist[num];
	int speed;
	int pre_speed=0;
  bool dirc = false;
  bool cont = true;

  while (cont) {
   // check if receive command to exit following mode
   if (!vexRT(Btn5U))       // Btn5U is released
      b5urel= true;

   if (b5urel & vexRT(Btn5U) ) {  // Btn5U is pressed again to exit following mode
     cont = false;
     b5urel = false;
   }

   // measure distance between robot and the guide
 		int k;
		for (k=0; k<num; k++) {
			wait1Msec(50);
		  dist[k]=SensorValue(sonar);
      if (dist[k]==-1)
			   dist[k]=500;
	   }
	  int dist2= majvote(dist, num);

		speed=(dist2-50);

		if (speed<0)
			speed=3*speed;   // scale up the negative speed since negative distance is typicall small

    if ((speed>0 & pre_speed<0)|(speed<0 & pre_speed>0))
    	dirc=true;
    else
    	dirc=false;

	  if (abs(speed)<30)
			speed =0;

		pre_speed=speed;

		if (dirc){          // if robot chnages directions, let it stop first to avoid jerking
			motor(lm)=0;
		  motor(rm)=0;
		  wait1Msec(300);
		}
		else {
			motor(lm)=speed;
		  motor(rm)=speed;
		}
 }

 // stop the motor
 motor(lm)=0;
 motor(rm)=0;
 turnLEDOff(yLED);
}

// run a square
void runSquare() {
	turnLEDOn(rLED);
	int k;
	for (k=0; k<4; k++) {
		march(36);
		wait1Msec(200);
		turn(rtv);
		wait1Msec(200);
	}
	turnLEDOff(rLED);
}

// run a circle
void runCircle() {
	turnLEDOff(gLED);
	turnLEDOn(yLED);

  int speedL = 127;
  int speedR = 27;

  SensorValue[lenc]=0;          // reset left wheel encoder counters before using
  int target = lwt;

  while (abs(SensorValue[lenc])<target) {
		motor[rm]=speedR;
		motor[lm]=speedL;
		wait1Msec(10);
	}

	//stop motors
	motor[rm]=0;
	motor[lm]=0;


	turnLEDOn(gLED);
	turnLEDOff(yLED);
}

// calibration fucntion
void calibrate() {
  bool calcont = true;

  bool b7up = false;
  bool b7dp = false;

  bool b7lp = false;
  bool b7rp = false;

  bool b8up = false;
  bool b8dp = false;

  turnLEDOn(rLED);

  while(calcont) {

   // check if receive command to exit calibration
   if ((!vexRT(Btn5D)) & (!vexRT(Btn6D))) {      // both buttons are released
     btnrel=true;
     turnLEDOff(gLED);
   }
   if (btnrel & vexRT(Btn5D) & vexRT(Btn6D)) {  // exit calibration mode
     calcont = false;
     btnrel = false;
   }

   // check if to increase right turn value rtv
   if (vexRT(Btn7U))
     b7up = true;

   if (b7up & (!vexRT(Btn7U))) {
     b7up = false;
     rtv = rtv + 1;
     turnLEDOff(rLED);
     wait1Msec(100);
     turnLEDOn(rLED);
   }

   // check if to decrease right turn value rtv
   if (vexRT(Btn7D))
     b7dp = true;

   if (b7dp & (!vexRT(Btn7D))) {
     b7dp = false;
     rtv = rtv - 1;
     turnLEDOff(rLED);
     wait1Msec(100);
     turnLEDOn(rLED);
   }

   // check if to increase right wheel speed adjustment rsa
   if (vexRT(Btn8U))
     b8up = true;

   if (b8up & (!vexRT(Btn8U))) {
     b8up = false;
     rsa = rsa + 1;
     turnLEDOff(rLED);
     wait1Msec(100);
     turnLEDOn(rLED);
   }

   // check if to decrease right wheel speed adjustment rsa
   if (vexRT(Btn8D))
     b8dp = true;

   if (b8dp & (!vexRT(Btn8D))) {
     b8dp = false;
     rsa = rsa - 1;
     turnLEDOff(rLED);
     wait1Msec(100);
     turnLEDOn(rLED);
   }

   // check if to increase rsd
   if (vexRT(Btn7L))
     b7lp = true;

   if (b7lp & (!vexRT(Btn7L))) {
     b7lp = false;
     rsd = rsd + 0.05;
     lwt=lwt+100;
     turnLEDOff(rLED);
     wait1Msec(100);
     turnLEDOn(rLED);
   }

   // check if to decrease rsd
   if (vexRT(Btn7R))
     b7rp = true;

   if (b7rp & (!vexRT(Btn7R))) {
     b7rp = false;
     rsd = rsd - 0.05;
     lwt=lwt-100;
     turnLEDOff(rLED);
     wait1Msec(100);
     turnLEDOn(rLED);
   }
 }
	turnLEDOff(rLED);
	turnLEDOn(gLED);
}


void remoteControl() {

   // light red  and yellow LED
   turnLEDOn(rLED);
   turnLEDOn(yLED);

   bool cont = true;

  while (cont) {
   // check if receive command to exit remote control mode
   if (!vexRT(Btn8L))       // Btn8L is released
      b8lrel= true;

   if (b8lrel & vexRT(Btn8L) ) {  // Btn8L is pressed again to exit remote control mode
     cont = false;
     b8lrel = false;
   }

   // start remote control function
   // claw control
   while(vexRT[Btn5D]){
		motor[Claw]=30;}

	 while(vexRT[Btn5U]){
		motor[Claw]=-30;}

   motor[Claw]=0;

   // motor control
	int lvalue;
	int rvalue;

	lvalue=vexRT[Ch3];
	if(lvalue<20&&lvalue>-20)
		lvalue=0;

	rvalue=vexRT[Ch2];
	if(rvalue<20&&rvalue>-20)
		rvalue=0;

  int dist = SensorValue(sonar);

  if (dist<50 & dist!=-1) {
  	if (lvalue>0)
          lvalue=0;

    if (rvalue>0)
         rvalue=0;
	 }

	 motor[lm]=lvalue;
	 motor[rm]=rvalue;

	// arm control
	while(vexRT[Btn6U] & SensorValue(armpos)<up){
		motor[Arm]=30;}

	while(vexRT[Btn6D] & SensorValue(armpos)>lp){
		motor[Arm]=-30;}

	motor[Arm]=0;

 }

 // turn of red LED
 turnLEDOff(rLED);
 turnLEDOff(yLED);
}


// Main funciton
task main() {

 turnLEDOn(gLED);     // notify user that the robot is ready

 while(true) {

    // check if any button is pressed
    if (b5urel & vexRT[Btn5U]) {
    	b5urel = false;
    	follow();
      }

    if (!vexRT(Btn5U))
    	b5urel = true;

     // Btn8L is pressed to enter remote control mode
    if (b8lrel & vexRT[Btn8L]) {
    	b8lrel = false;
    	remoteControl();
      }

    if (!vexRT(Btn8L))
    	b8lrel = true;


    if (vexRT[Btn6U])
    	 runCircle();

    if (vexRT[Btn8R])
    	 runSquare();

    if (btnrel & vexRT(Btn5D) & vexRT(Btn6D)) {
    	btnrel = false;
    	calibrate();
     }

    if ((!vexRT(Btn5D)) & (!vexRT(Btn6D)))      // both buttons are released
       btnrel=true;
  }
}
