#pragma config(Sensor, in1,    armpos,            sensorPotentiometer)
#pragma config(Sensor, dgtl1,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  renc,           sensorQuadEncoder)
#pragma config(Sensor, dgtl11, lenc,           sensorQuadEncoder)
#pragma config(Motor,  port1,           rm,            tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port10,          lm,            tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port9,           Claw,          tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port8,           Arm,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Sensor, dgtl5,  rLED,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl6,  gLED,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl7,  yLED,           sensorLEDtoVCC)
//*!!Code automatically generated by 'ROBOTC' configuration wizard


/*
*  1) push both btn5D and btn6D to enter and exit calibarion mode (red LED on)
*  2) push both btn5U and btn6U to enter and exit remote control mode (all LED on)
*  3) Push btn7U to start writing operation (green LED on)
*/

/* calibration mode operation
 * Btn7U: increase left turn adjustment value (the first turn after writing)
 * Btn7D: decrease left turn adjustment value
 * Btn7L: increase right turn adjustment value (the second turn to get back writing orientation)
 * Btn7R: decrease right turn adjustment value
 * Btn8U: increase backup distance
 * Btn8D: decrease backup distance
 * Btn8L: increase move forward distance (after writing the last vertical line of H)
 * Btn8R: decrease move forward distance
 *
 */


#define up 100
#define lp 1111

int ltv = 70;        // left turn adjustment value
int rtv = 73;        // right turn adjustment value
int buv = 0;        // backup distance adjustment
int fdv = 0;        // forward distance adjustment

bool btnrel = true;
bool buprel = true;


void moveArm(int position, int agf) {
	if (position<up)        // check position limits.
	   position = up;

	if (position>lp)
  	   position =lp;

	int pos;
	bool cont=true;
	bool brake = false;

	while(cont) {
		pos=position-SensorValue(armpos);
		if(pos>5) {  // the arm is higher than the desirable position
		  motor[Arm]=-15;      // lower arm
		  //brake = true;      // disable brake position in this application
		}
		else {
			if (pos<-5) {  // the arm is lower than the desirable position
				motor[Arm]=40;   // raise arm
				//brake = false;
				}
	    else {            // arm at the desirable position
	    	cont=false;
	    	if (brake) {      // need to apply brake to counter inertia
	    		motor[Arm]=20;
	    		wait1Msec(50);
	    	 }
	    	   motor[Arm]=agf;   // this is to counter gravity and hold motor at that position
	    	   //wait1Msec(100);
	    	   //motor[Arm]=0;
	    }   // end if (pos<-20)... else...
	  }   // end if (pos>20)... else...
  }  	  // end while
}       // end sub routine

void turn (int degree) {
	int target;
	int speedR, speedL;

	target=abs(3*degree);

	if (degree>0) {
		speedR=50;
		speedL=-50;
	}
	else {
		speedR=-50;
		speedL=50;
	}

	SensorValue[renc]=0;                  // reset the encoder counters beforing using them
	SensorValue[lenc]=0;                  // reset the encoder counters beforing using them

	while (abs(SensorValue[renc])<target | abs(SensorValue[lenc])<target) {
		motor[rm]=speedR;
		motor[lm]=speedL;
		wait1Msec(10);
	}

	// apply brake
	if (speedR>0){
		speedR=-30;
		speedL=30;
	}
	else {
		speedR=30;
		speedL=-30;
	}

	motor[rm]=speedR;
	motor[lm]=speedL;
	wait1Msec(100);
	motor[rm]=0;
	motor[lm]=0;
}

void march(float dist){
	int target;
	int speedR, speedL;
	target=(int) abs(dist*28.64789);

	if (dist>0){
		speedR=45;
		speedL=45;
		}
	else {
		speedR=-45;
		speedL=-45;
	}

	SensorValue[renc]=0;                  // reset the encoder counters beforing using them
	SensorValue[lenc]=0;                  // reset the encoder counters beforing using them

	while (abs(SensorValue[renc])<target | abs(SensorValue[lenc])<target) {
		motor[rm]=speedR;
		motor[lm]=speedL;
		wait1Msec(10);
	}

	// apply brake
	if (speedR>0){
		speedR=-25;
		speedL=25;
	}
	else {
		speedR=25;
		speedL=-25;
	}

	motor[rm]=speedR;
	motor[lm]=speedL;
	wait1Msec(100);
	motor[rm]=0;
	motor[lm]=0;
}

void calibrate() {
  bool calcont = true;

  bool b7up = false;
  bool b7dp = false;

  bool b7le = false;
  bool b7ri = false;

  bool b8up = false;
  bool b8dp = false;

  bool b8le = false;
  bool b8ri = false;


  turnLEDOn(rLED);
  turnLEDOff(gLED);

  while(calcont) {

   // check if receive command to exit calibration
   if ((!vexRT(Btn5D)) & (!vexRT(Btn6D))) {      // both buttons are released
     btnrel=true;
   }
   if (btnrel & vexRT(Btn5D) & vexRT(Btn6D)) {  // exit calibration mode
     calcont = false;
     btnrel = false;
   }

   // check if to increase left turn adjustment value ltv
   if (vexRT(Btn7U))
     b7up = true;

   if (b7up & (!vexRT(Btn7U))) {
     b7up = false;
     ltv = ltv + 1;
     turnLEDOff(rLED);
     wait1Msec(100);
     turnLEDOn(rLED);
   }

   // check if to decrease left turn value btv
   if (vexRT(Btn7D))
     b7dp = true;

   if (b7dp & (!vexRT(Btn7D))) {
     b7dp = false;
     ltv = ltv - 1;
     turnLEDOff(rLED);
     wait1Msec(100);
     turnLEDOn(rLED);
   }

   // check if to increase right turn value rtv
   if (vexRT(Btn7L))
     b7le = true;

   if (b7le & (!vexRT(Btn7L))) {
     b7le = false;
     rtv = rtv + 1;
     turnLEDOff(rLED);
     wait1Msec(100);
     turnLEDOn(rLED);
   }

   // check if to decrease back turn value btv
   if (vexRT(Btn7R))
     b7ri = true;

   if (b7ri & (!vexRT(Btn7R))) {
     b7ri = false;
     rtv = rtv - 1;
     turnLEDOff(rLED);
     wait1Msec(100);
     turnLEDOn(rLED);
   }


   // check if to increase backup distance adjustment buv
   if (vexRT(Btn8U))
     b8up = true;

   if (b8up & (!vexRT(Btn8U))) {
     b8up = false;
     buv = buv + 1;
     turnLEDOff(rLED);
     wait1Msec(100);
     turnLEDOn(rLED);
   }

   // check if to decrease backup distance adjustment buv
   if (vexRT(Btn8D))
     b8dp = true;

   if (b8dp & (!vexRT(Btn8D))) {
     b8dp = false;
     buv = buv - 1;
     turnLEDOff(rLED);
     wait1Msec(100);
     turnLEDOn(rLED);
   }

   // check if to increase forward distance adjustment fdv
   if (vexRT(Btn8L))
     b8le = true;

   if (b8le & (!vexRT(Btn8L))) {
     b8le = false;
     fdv = fdv + 1;
     turnLEDOff(rLED);
     wait1Msec(100);
     turnLEDOn(rLED);
   }

   // check if to decrease forward distance adjustment fdv
   if (vexRT(Btn8R))
     b8ri = true;

   if (b8ri & (!vexRT(Btn8R))) {
     b8ri = false;
     fdv = fdv - 1;
     turnLEDOff(rLED);
     wait1Msec(100);
     turnLEDOn(rLED);
   }

 }  // end while(calibration)

	turnLEDOff(rLED);
	turnLEDOn(gLED);
}


	void bigline() {
		moveArm(lp,-5);
		wait1Msec(1000);
		march(-4);
		wait1Msec(350);
		moveArm(950, 10);
		wait1Msec(1500);
		turn(ltv);
		wait1Msec(1500);
		march(-0.1);
		wait1Msec(1500);
		turn(-rtv);
		wait1Msec(1500);
		march(6);
		wait1Msec(1500);
	}

	void bigline2() {
		moveArm(lp,-5);
		wait1Msec(1000);
		march(-4);
		wait1Msec(1000);
		moveArm(950, 10);
	}


	void smallline() {
		moveArm(lp,-5);
		wait1Msec(1000);
		march(-1.5);
		wait1Msec(1500);
		moveArm(950, 10);
		wait1Msec(1500);
		march(-2.5);       // since the robot only travels a short line in writing
		wait1Msec(1500);
		turn(ltv);
		wait1Msec(1500);
		march(-0.1);
		wait1Msec(1500);
		turn(-rtv);
		wait1Msec(1500);
		march(7);
		wait1Msec(1500);
	}


void remoteControl() {
   // light red LED
   turnLEDOn(rLED);
   turnLEDOn(yLED);

   bool cont = true;

  while (cont) {
   // check if receive command to exit remote control
   if ((!vexRT(Btn5U)) & (!vexRT(Btn6U))) {      // both buttons are released
     buprel=true;
   }
   if (buprel & vexRT(Btn5U) & vexRT(Btn6U)) {  // exit remote control mode
     cont = false;
     buprel = false;
   }


   // start remote control function
   // claw control
   while(vexRT[Btn5D]){
		motor[Claw]=30;}

	 while(vexRT[Btn5U]){
		motor[Claw]=-30;}

   motor[Claw]=0;

   // motor control
	int lvalue;
	int rvalue;

	lvalue=vexRT[Ch3];
	if(lvalue<10&&lvalue>-10)
		lvalue=0;

	rvalue=vexRT[Ch2];
	if(rvalue<10&&rvalue>-10)
		rvalue=0;

  int dist = SensorValue(sonar);

  if (dist<50 & dist!=-1) {
  	if (lvalue>0)
          lvalue=0;

    if (rvalue>0)
         rvalue=0;
	 }

	 motor[lm]=lvalue;
	 motor[rm]=rvalue;

	// arm control
	while(vexRT[Btn6U] & SensorValue(armpos)>up){
		motor[Arm]=30;}

	while(vexRT[Btn6D] & SensorValue(armpos)<lp){
		motor[Arm]=-30;}

	motor[Arm]=0;

 }
 // reset motor speeds
 motor[Arm]=0;
 motor[Claw]=0;
 motor[rm]=0;
 motor[lm]=0;

 // turn of red LED
 turnLEDOff(rLED);
 turnLEDOff(yLED);

}

task main(){

    turnLEDOn(gLED);

	while (true){

	// start writing operation
	if (vexRT(Btn7U)) {
		motor[Claw]=-25;     //tighten grip
		motor[Arm]=90;       //move arm up
		wait1Msec(650);
		motor[Arm]=0;       //stop motor
		wait1Msec(100);
	  motor[Arm]=-15;       //change motor direction
		wait1Msec(100);
		motor[Arm]=0;        //move arm down by inertia
		wait1Msec(500);

		smallline();         //draw small line for 4
		bigline();           //draw big line for 4
		bigline();           //draw big line for H
		bigline2();          //draw big line for H
		march(11+fdv);           //move up
		wait1Msec(1000);
		turn(ltv);            //turn
		wait1Msec(1000);
		march(-(1.5+buv));         //back up

		// draw the first horizontal line
		moveArm(lp,-5);
		wait1Msec(1500);
		march(-1.5);              // Is this too long?
    wait1Msec(1500);
		moveArm(950,10);
		wait1Msec(1500);

		march(-2);
	  wait1Msec(1500);
		moveArm(lp,-5);
		wait1Msec(1500);
		march(-2);             // second horizontal line

		moveArm(950,10);
		}

  // entrance point to calibration mode
	if (btnrel & vexRT(Btn5D) & vexRT(Btn6D)) {
    	btnrel = false;
    	calibrate();
     }

   if ((!vexRT(Btn5D)) & (!vexRT(Btn6D)))      // both buttons are released
       btnrel=true;

  // entrance point to remote control mode
  	if (buprel & vexRT(Btn5U) & vexRT(Btn6U)) {
    	buprel = false;
    	remoteControl();
     }

   if ((!vexRT(Btn5U)) & (!vexRT(Btn6U)))      // both buttons are released
       buprel=true;
 }
}
